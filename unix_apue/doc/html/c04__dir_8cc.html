<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>unix_apue: E:/git_thub/program/unix_apue/code/c04_file_dir/c04_dir.cc 文件参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">unix_apue
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','搜索');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_4c8e4344be699fca3cf41d2f943a611f.html">c04_file_dir</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">函数</a>  </div>
  <div class="headertitle">
<div class="title">c04_dir.cc 文件参考</div>  </div>
</div><!--header-->
<div class="contents">

<p>练习文件和目录操作  
<a href="#details">更多...</a></p>
<div class="textblock"><code>#include &lt;fcntl.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;utime.h&gt;</code><br />
<code>#include &lt;sys/stat.h&gt;</code><br />
<code>#include &lt;dirent.h&gt;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
</div>
<p><a href="c04__dir_8cc_source.html">浏览源代码.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:ab6a219bbe902c8c9b0528e0dd45ee905"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c04__dir_8cc.html#ab6a219bbe902c8c9b0528e0dd45ee905">test_stat</a> (const char *file_name)</td></tr>
<tr class="memdesc:ab6a219bbe902c8c9b0528e0dd45ee905"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试stat函数  <a href="#ab6a219bbe902c8c9b0528e0dd45ee905">更多...</a><br /></td></tr>
<tr class="separator:ab6a219bbe902c8c9b0528e0dd45ee905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ed8c2896baae8cadb1cad9ddd91957"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c04__dir_8cc.html#a90ed8c2896baae8cadb1cad9ddd91957">test_access</a> (const char *pathname, int mode)</td></tr>
<tr class="memdesc:a90ed8c2896baae8cadb1cad9ddd91957"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试access函数  <a href="#a90ed8c2896baae8cadb1cad9ddd91957">更多...</a><br /></td></tr>
<tr class="separator:a90ed8c2896baae8cadb1cad9ddd91957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8eeda87f82af599a06958b405f3790"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c04__dir_8cc.html#aae8eeda87f82af599a06958b405f3790">test_umask</a> (mode_t cmask)</td></tr>
<tr class="memdesc:aae8eeda87f82af599a06958b405f3790"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试umask函数  <a href="#aae8eeda87f82af599a06958b405f3790">更多...</a><br /></td></tr>
<tr class="separator:aae8eeda87f82af599a06958b405f3790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6430b525bc373104130a4e6c2dc6ea55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c04__dir_8cc.html#a6430b525bc373104130a4e6c2dc6ea55">test_chmod</a> (const char *file_path, mode_t cmask)</td></tr>
<tr class="memdesc:a6430b525bc373104130a4e6c2dc6ea55"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试chmod函数  <a href="#a6430b525bc373104130a4e6c2dc6ea55">更多...</a><br /></td></tr>
<tr class="separator:a6430b525bc373104130a4e6c2dc6ea55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00630f51f94ce581b7e6eb57e250537"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c04__dir_8cc.html#ae00630f51f94ce581b7e6eb57e250537">test_chown</a> (const char *file_name, uid_t uid, gid_t gid)</td></tr>
<tr class="memdesc:ae00630f51f94ce581b7e6eb57e250537"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试chown函数  <a href="#ae00630f51f94ce581b7e6eb57e250537">更多...</a><br /></td></tr>
<tr class="separator:ae00630f51f94ce581b7e6eb57e250537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c9e8ec3a5362e3d890253ec5271937"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c04__dir_8cc.html#a47c9e8ec3a5362e3d890253ec5271937">test_truncate</a> (const char *file_name, off_t length)</td></tr>
<tr class="memdesc:a47c9e8ec3a5362e3d890253ec5271937"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试truncate函数  <a href="#a47c9e8ec3a5362e3d890253ec5271937">更多...</a><br /></td></tr>
<tr class="separator:a47c9e8ec3a5362e3d890253ec5271937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d75b8db9f2aeae95663fdf3a1821ce4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c04__dir_8cc.html#a9d75b8db9f2aeae95663fdf3a1821ce4">test_link</a> (const char *efile, const char *nfile)</td></tr>
<tr class="memdesc:a9d75b8db9f2aeae95663fdf3a1821ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试link函数  <a href="#a9d75b8db9f2aeae95663fdf3a1821ce4">更多...</a><br /></td></tr>
<tr class="separator:a9d75b8db9f2aeae95663fdf3a1821ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af894cac310b20079184aaec7c83ccb3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c04__dir_8cc.html#af894cac310b20079184aaec7c83ccb3e">test_rename</a> (const char *oldname, const char *newname)</td></tr>
<tr class="memdesc:af894cac310b20079184aaec7c83ccb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试rename函数  <a href="#af894cac310b20079184aaec7c83ccb3e">更多...</a><br /></td></tr>
<tr class="separator:af894cac310b20079184aaec7c83ccb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c087d773da51b0ea4c026b1d6228f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c04__dir_8cc.html#a31c087d773da51b0ea4c026b1d6228f7">test_symlink</a> (const char *actualpath, const char *sympath)</td></tr>
<tr class="memdesc:a31c087d773da51b0ea4c026b1d6228f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试symlink函数  <a href="#a31c087d773da51b0ea4c026b1d6228f7">更多...</a><br /></td></tr>
<tr class="separator:a31c087d773da51b0ea4c026b1d6228f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051b0c75489f39c54876853a03066c12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c04__dir_8cc.html#a051b0c75489f39c54876853a03066c12">test_utime</a> (const char *filename)</td></tr>
<tr class="memdesc:a051b0c75489f39c54876853a03066c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试utime函数  <a href="#a051b0c75489f39c54876853a03066c12">更多...</a><br /></td></tr>
<tr class="separator:a051b0c75489f39c54876853a03066c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc7f41abbba4a48cbcc84969790f7b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c04__dir_8cc.html#a3cc7f41abbba4a48cbcc84969790f7b0">test_mkdir</a> (const char *dirname, mode_t modes)</td></tr>
<tr class="memdesc:a3cc7f41abbba4a48cbcc84969790f7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试mkdir函数  <a href="#a3cc7f41abbba4a48cbcc84969790f7b0">更多...</a><br /></td></tr>
<tr class="separator:a3cc7f41abbba4a48cbcc84969790f7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf5ad8ae912c67319ffe6b9318e80fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c04__dir_8cc.html#acbf5ad8ae912c67319ffe6b9318e80fc">test_readdir</a> (const char *dirname)</td></tr>
<tr class="memdesc:acbf5ad8ae912c67319ffe6b9318e80fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试readdir函数  <a href="#acbf5ad8ae912c67319ffe6b9318e80fc">更多...</a><br /></td></tr>
<tr class="separator:acbf5ad8ae912c67319ffe6b9318e80fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af200e4d35b0de6273368f4ad027d72bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c04__dir_8cc.html#af200e4d35b0de6273368f4ad027d72bf">test_chdir</a> (const char *pathname)</td></tr>
<tr class="memdesc:af200e4d35b0de6273368f4ad027d72bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试chdir函数  <a href="#af200e4d35b0de6273368f4ad027d72bf">更多...</a><br /></td></tr>
<tr class="separator:af200e4d35b0de6273368f4ad027d72bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18b08a40d17cbd27ff8b4be995a36e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c04__dir_8cc.html#aa18b08a40d17cbd27ff8b4be995a36e4">test_getcwd</a> ()</td></tr>
<tr class="memdesc:aa18b08a40d17cbd27ff8b4be995a36e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试getcwd函数  <a href="#aa18b08a40d17cbd27ff8b4be995a36e4">更多...</a><br /></td></tr>
<tr class="separator:aa18b08a40d17cbd27ff8b4be995a36e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c04138a5bfe5d72780bb7e82a18e627"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c04__dir_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> (int argc, char **argv)</td></tr>
<tr class="separator:a3c04138a5bfe5d72780bb7e82a18e627"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>练习文件和目录操作 </p>
<dl class="section date"><dt>日期</dt><dd>2017/08/12 </dd></dl>

<p class="definition">在文件 <a class="el" href="c04__dir_8cc_source.html">c04_dir.cc</a> 中定义.</p>
</div><h2 class="groupheader">函数说明</h2>
<a id="a3c04138a5bfe5d72780bb7e82a18e627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c04138a5bfe5d72780bb7e82a18e627">&#9670;&nbsp;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="c04__dir_8cc_source.html">c04_dir.cc</a> 第 <a class="el" href="c04__dir_8cc_source.html#l01048">1048</a> 行定义.</p>

</div>
</div>
<a id="a90ed8c2896baae8cadb1cad9ddd91957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ed8c2896baae8cadb1cad9ddd91957">&#9670;&nbsp;</a></span>test_access()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_access </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试access函数 </p>
<p><code> int access(const char *pathname, int mode);</code></p>
<p><code>返回值：成功返回0， 失败返回-1</code></p>
<p><code>除非测试的文件不存在， 一般错误返回的提示都是Permission denied </code> </p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>access函数的mode常量</caption>
<tr>
<th width="40">序号</th><th width="100">模式</th><th>说明 </th></tr>
<tr>
<td>1</td><td>R_OK</td><td>测试读权限 </td></tr>
<tr>
<td>2</td><td>W_OK</td><td>测试写权限 </td></tr>
<tr>
<td>3</td><td>X_OK</td><td>测试执行权限 </td></tr>
<tr>
<td>4</td><td>F_OK</td><td>测试文件是否存在 </td></tr>
</table>
<dl class="section warning"><dt>警告</dt><dd>当用open函数打开一个文件时，内核以进程的有效用户ID和有效组ID为基础执行访问权限测试 </dd>
<dd>
有时，进程期望按实际用户ID和实际组ID来测试其访问能力 </dd>
<dd>
access函数就是按实际用户ID和实际组ID进行访问权限测试的 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathname</td><td>文件路径 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>测试文件属性 </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c04__dir_8cc_source.html">c04_dir.cc</a> 第 <a class="el" href="c04__dir_8cc_source.html#l00231">231</a> 行定义.</p>

</div>
</div>
<a id="af200e4d35b0de6273368f4ad027d72bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af200e4d35b0de6273368f4ad027d72bf">&#9670;&nbsp;</a></span>test_chdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_chdir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试chdir函数 </p>
<ul>
<li>
每个进程都有一个当前工作目录，此目录是搜索所有相对路径名的起点 </li>
<li>
当前工作目录通常是在用户登录系统时，从口令文件（/etc/passwd）中获取的 </li>
<li>
当前工作目录是进程的一个属性，起始目录则是登录名的一个属性 </li>
<li>
进程通过调用chdir和fchdir函数可以更改当前工作目录，在这两个函数中，分别用pathname或打开文件描述符来指定新的当前工作目录 </li>
</ul>
<p><code> int chdir(const char *pathname);</code></p>
<p><code>int fchdir(int filedes);</code></p>
<p><code>返回值：成功返回0， 出错返回-1 </code> </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathname</td><td>跳转的目录 </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c04__dir_8cc_source.html">c04_dir.cc</a> 第 <a class="el" href="c04__dir_8cc_source.html#l00967">967</a> 行定义.</p>

</div>
</div>
<a id="a6430b525bc373104130a4e6c2dc6ea55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6430b525bc373104130a4e6c2dc6ea55">&#9670;&nbsp;</a></span>test_chmod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_chmod </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>cmask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试chmod函数 </p>
<p><code> int chmod(const char *pathname, mode_t mode);</code></p>
<p><code> int fchmod(int filedes, mode_t mode);</code></p>
<p><code> 返回值：成功返回0， 失败返回-1 </code> </p><ul>
<li>
chmod在指定的文件上进行操作，fchmod函数则对已打开的文件进行操作 </li>
<li>
为了改变一个文件的权限位，进程的有效用户ID必须等于文件的所有者ID，或者进程必须具有超级用户权限 </li>
<li>
参数mode是下面常量按位或运算构成的 <a class="anchor" id=""></a>
<table class="doxtable">
<caption>chmod函数的mode常量</caption>
<tr>
<th width="40">序号</th><th width="40">分类</th><th width="100">mode</th><th>描述 </th></tr>
<tr>
<td>1</td><td rowspan="3"></td><td>S_ISUID</td><td>执行时设置用户ID </td></tr>
<tr>
<td>2</td><td>S_ISGID</td><td>执行时设置组ID </td></tr>
<tr>
<td>3</td><td>S_ISVTX</td><td>保存正文(粘住位) </td></tr>
<tr>
<td>4</td><td rowspan="4">用户</td><td>S_IRWXU</td><td>用户(所有者)读、写和执行 </td></tr>
<tr>
<td>5</td><td>S_IRUSR</td><td>用户（所有者）读 </td></tr>
<tr>
<td>6</td><td>S_IWUSR</td><td>用户（所有者）写 </td></tr>
<tr>
<td>7</td><td>S_IXUSR</td><td>用户（所有者）执行 </td></tr>
<tr>
<td>8</td><td rowspan="4">组</td><td>S_IRWXG</td><td>组读、写和执行 </td></tr>
<tr>
<td>9</td><td>S_IRGRP</td><td>组读 </td></tr>
<tr>
<td>10</td><td>S_IWRGP</td><td>组写 </td></tr>
<tr>
<td>11</td><td>S_IXGRP</td><td>组执行 </td></tr>
<tr>
<td>12</td><td rowspan="4">其他</td><td>S_IRWXO</td><td>其他读、写和执行 </td></tr>
<tr>
<td>13</td><td>S_IROTH</td><td>其他读 </td></tr>
<tr>
<td>14</td><td>S_IWOTH</td><td>其他写 </td></tr>
<tr>
<td>15</td><td>S_IXOTH</td><td>其他执行 </td></tr>
</table>
</li>
</ul>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_path</td><td>文件名 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmask</td><td>文件访问权限位 </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c04__dir_8cc_source.html">c04_dir.cc</a> 第 <a class="el" href="c04__dir_8cc_source.html#l00392">392</a> 行定义.</p>

</div>
</div>
<a id="ae00630f51f94ce581b7e6eb57e250537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00630f51f94ce581b7e6eb57e250537">&#9670;&nbsp;</a></span>test_chown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_chown </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uid_t&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gid_t&#160;</td>
          <td class="paramname"><em>gid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试chown函数 </p>
<p><code> int chown(const char *pathname, uid_t owner, gid_t group);</code></p>
<p><code> int fchown(int filedes, uid_t owner, gid_t group);</code></p>
<p><code> int lchown(const char *pathname, uid_t owner, gid_t group);</code></p>
<p><code> 返回值：成功返回0， 失败返回-1 </code> </p><ul>
<li>
三个函数的操作类似 </li>
<li>
在符号链接的情况下，lchown更改符号链接本身的所有者，而不是该符号链接所指向的文件 </li>
<li>
两个参数owner或group中的任意一个是-1， 则对应的ID不变 </li>
<li>
基于BSD的系统一直规定只有超级用户才能更改一个文件的所有者，这样是为了防止用户改变其文件的所有者从而摆脱磁盘空间限额对他们的限制<br />
系统V则允许任一用户更改他们拥有的文件的所有者 </li>
<li>
如果设置了常量__POSIX_CHOWN_RESTRICTED对指定的文件起作用，则： <ol>
<li>
只有超级用户进程能更改该文件的用户ID </li>
<li>
若满足下列2个条件，一个非超级用户进程可以更改该文件的组ID<br />
 (a)进程拥有此文件（其中有效用户ID等于该文件的用户ID）<br />
 (b)参数owner等于-1或文件的用户ID，并且参数group等于进程的有效组ID或进程的附加组ID之一 </li>
</ol>
<br />
 这预示着，当__POSIX_CHOWN_RESTRICTED起作用时，不能更改其他用户文件的用户ID<br />
 你可以更改你所拥有的文件组ID，但只能改到你所属的组 </li>
<li>
若这些函数由非超级用户进程调用，则在成功返回时，该文件的设置用户ID为和设置组ID位都会被清除 </li>
</ul>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>文件名 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uid</td><td>用户id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gid</td><td>组id </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c04__dir_8cc_source.html">c04_dir.cc</a> 第 <a class="el" href="c04__dir_8cc_source.html#l00482">482</a> 行定义.</p>

</div>
</div>
<a id="aa18b08a40d17cbd27ff8b4be995a36e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18b08a40d17cbd27ff8b4be995a36e4">&#9670;&nbsp;</a></span>test_getcwd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_getcwd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试getcwd函数 </p>
<p>获取当前工作目录的绝对路径</p>
<p><code> char *getcwd(char *buf, size_t size);</code></p>
<p><code>返回值：成功则返回buf，出错则返回NULL </code></p>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c04__dir_8cc_source.html">c04_dir.cc</a> 第 <a class="el" href="c04__dir_8cc_source.html#l01010">1010</a> 行定义.</p>

</div>
</div>
<a id="a9d75b8db9f2aeae95663fdf3a1821ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d75b8db9f2aeae95663fdf3a1821ce4">&#9670;&nbsp;</a></span>test_link()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_link </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>efile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nfile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试link函数 </p>
<p><code> int link(const char *existingpath, const char *newpath);</code></p>
<p><code>int ulink(const char *pathname);</code></p>
<p><code>返回值：若成功则返回0， 若出错则返回-1 </code> </p><ul>
<li>
link，函数创建一个新目录项newpath(硬链接)，所以任何一个文件可以有多个目录项指向i节点 </li>
<li>
link，若newpath已经存在，则返回出错 </li>
<li>
link，只创建newpath中的最后一个分量，路径中的其他部分应当已经存在 </li>
<li>
unlink，删除一个现有的目录项，并将由pathname所引用文件的链接计数减1 </li>
<li>
unlink，如果还有指向该文件的其他链接，则仍可通过其他链接访问该文件的数据，只有当链接计数达到0时，该文件的内容才可被删除，另一个条件也会阻止删除文件的内容&mdash;只要有进程打开了该文件，其内容也不能删除。unlink的这种性质经常被程序用来确保即使是在该程序崩溃时，它所创建的临时文件也不会遗留下来。进程用open或creat创建一个文件，然后立即调用unlink。因为该文件仍旧是打开的，所以不会讲其内容删除，只有当进程关闭该文件或终止时，该文件的内容才会被删除。 </li>
<li>
unlink，如果出错，则不对该文件做任何更改 </li>
<li>
unlink，如果pathname是符号链接，那么unlink删除该符号链接，而不会删除由该链接所引用的文件 </li>
</ul>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c04__dir_8cc_source.html">c04_dir.cc</a> 第 <a class="el" href="c04__dir_8cc_source.html#l00572">572</a> 行定义.</p>

</div>
</div>
<a id="a3cc7f41abbba4a48cbcc84969790f7b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc7f41abbba4a48cbcc84969790f7b0">&#9670;&nbsp;</a></span>test_mkdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_mkdir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>modes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试mkdir函数 </p>
<p><code> int mkdir(const char *pathname, mode_t mode);</code></p>
<p><code>int rmdir(const char *pathname);</code></p>
<p><code>返回值：若成功则返回0， 若出错则返回-1 </code> </p><ul>
<li>
mkdir, 函数创建一个新的空目录， 所指定的文件访问权限mode由进程的文件模式创建屏蔽字修改 </li>
<li>
mkdir, 常见的错误是指定与文件相同的mode（只指定读、写权限），但是，对于目录通常至少要设置1个执行权限位，以允许访问该目录中的文件名 </li>
<li>
rmdir, 函数可以删除一个空目录 </li>
<li>
rmdir, 如果调用此函数使目录的链接计数成为0，并且也没有其他进程打开此目录，则释放由此目录占用的空间；如果在链接计数达到0时，有一个或几个进程打开了此目录，则在此函数返回前删除最后一个链接，另外，在此目录中不能在创建新文件，但是在最后一个进程关闭它之前并不释放此目录 </li>
</ul>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dirname</td><td>目录名称 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modes</td><td>模式 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>警告</dt><dd>不能一次创建多级目录(mkdir failed(No such file or directory)); 不能创建已存在的目录(mkdir failed(File exists)); </dd></dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c04__dir_8cc_source.html">c04_dir.cc</a> 第 <a class="el" href="c04__dir_8cc_source.html#l00831">831</a> 行定义.</p>

</div>
</div>
<a id="acbf5ad8ae912c67319ffe6b9318e80fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf5ad8ae912c67319ffe6b9318e80fc">&#9670;&nbsp;</a></span>test_readdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_readdir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试readdir函数 </p>
<p><code> DIR *opendir(const char *pathname);</code></p>
<p><code>返回值：成功返回指针，出错返回NULL</code></p>
<p><code>struct dirent *readdir(DIR *dp);</code></p>
<p><code>返回值：成功返回指针，在目录结尾或出错则返回NULL</code></p>
<p><code>void rewinddir(DIR *dp);</code></p>
<p><code>void closedir(DIR *dp);</code></p>
<p><code>返回值：若成功则返回0，若出错则返回-1</code></p>
<p><code>long telldir(DIR *dp);</code></p>
<p><code>返回值：与dp关联的目录中的当前位置</code></p>
<p><code>void seekdir(DIR *dp, long loc); </code></p>
<p>struct dirent{<br />
 ino_t d_ino; // i-node number<br />
 char d_name[NAME_MAX + 1]; // null-terminated filename<br />
 }<br />
</p>
<dl class="section warning"><dt>警告</dt><dd>对某个目录具有访问权限的任一用户都可读该目录，但是，为了防止文件系统产生混乱，只有内核才能写目录。 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dirname</td><td>将要读取的目录 </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c04__dir_8cc_source.html">c04_dir.cc</a> 第 <a class="el" href="c04__dir_8cc_source.html#l00939">939</a> 行定义.</p>

</div>
</div>
<a id="af894cac310b20079184aaec7c83ccb3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af894cac310b20079184aaec7c83ccb3e">&#9670;&nbsp;</a></span>test_rename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_rename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>oldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试rename函数 </p>
<p><code> int rename(const char *oldname, const char *newname);</code></p>
<p><code>返回值：若成功则返回0， 若出错则返回-1</code></p>
<p><code></code> rename可以对文件或目录进行更名操作，根据oldname是指文件还是目录， 有几种情况需要说明 </p><ol>
<li>
若oldname是文件，如果newname已存在，则它不能引用一个目录， 如果newname已存在，而且不是一个目录，则先将该目录项删除然后将oldname更名为newname。对包含oldname的目录以及包含newname的目录，调用进程必须具有写权限，因为将更改这两个目录 </li>
<li>
若oldname是目录，如果newname已存在，则它必须引用一个目录，而且该目录应当是空目录。如果newname存在且为空目录，则先将其删除， 然后将oldname更名为newname。另外，当为一个目录更名时，newname不能包含oldname作为其路径前缀。 </li>
<li>
若oldname或newname引用符号链接，则处理的石符号链接本身，而不是它所引用的文件 </li>
<li>
若oldname和newname引用同一个文件，则函数不做任何更改而成功返回。 </li>
</ol>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">oldname</td><td>旧的名称 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newname</td><td>新的名称</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c04__dir_8cc_source.html">c04_dir.cc</a> 第 <a class="el" href="c04__dir_8cc_source.html#l00611">611</a> 行定义.</p>

</div>
</div>
<a id="ab6a219bbe902c8c9b0528e0dd45ee905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a219bbe902c8c9b0528e0dd45ee905">&#9670;&nbsp;</a></span>test_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_stat </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试stat函数 </p>
<a class="anchor" id=""></a>
<table class="doxtable">
<caption>stat函数三种形态</caption>
<tr>
<th width="40">序号</th><th width="500">原型</th><th>描述 </th></tr>
<tr>
<td>1</td><td>int stat(const char *restrict pathname, struct stat *restrict buf);</td><td><ul>
<li>
成功返回0， 出错返回-1</li>
</ul>
</td></tr>
<tr>
<td>2</td><td>int fstat(int filedes, struct stat *buf);</td><td><ul>
<li>
成功返回0， 出错返回-1</li>
</ul>
</td></tr>
<tr>
<td>3</td><td>int lstat(const char *restrict pathname, struct stat *restrict buf);</td><td><ul>
<li>
成功返回0， 出错返回-1</li>
<li>
类似stat，但当文件是符号链接时，返回该符号链接的信息，而不是由该符号链接引用文件的信息</li>
</ul>
</td></tr>
</table>
<a class="anchor" id=""></a>
<table class="doxtable">
<caption>struct stat结构体分析</caption>
<tr>
<th width="40">序号</th><th width="300">成员</th><th>描述 </th></tr>
<tr>
<td>1</td><td>类型：mode_t &mdash;&gt;&gt; 名称：<b>st_mode</b></td><td>文件类型 和 模式权限  </td></tr>
<tr>
<td>2</td><td>类型：ino_t &mdash;&gt;&gt; 名称：<b>st_ino</b></td><td>i-node号（serial number） </td></tr>
<tr>
<td>3</td><td>类型：dev_t &mdash;&gt;&gt; 名称：<b>st_dev</b></td><td>device number(file system) </td></tr>
<tr>
<td>4</td><td>类型：dev_t &mdash;&gt;&gt; 名称：<b>st_rdev</b></td><td>device number of special files </td></tr>
<tr>
<td>5</td><td>类型：nlink_t &mdash;&gt;&gt; 名称：<b>st_nlink</b></td><td>number of links </td></tr>
<tr>
<td>6</td><td>类型：uid_t &mdash;&gt;&gt; 名称：<b>st_uid</b></td><td>user ID of owner  </td></tr>
<tr>
<td>7</td><td>类型：gid_t &mdash;&gt;&gt; 名称：<b>st_gid</b></td><td>group ID of owner  </td></tr>
<tr>
<td>8</td><td>类型：off_t &mdash;&gt;&gt; 名称：<b>st_size</b></td><td>size in bytes, for regular files <br />
此字段只对普通文件、目录文件和符号链接有意义<br />
 <ul>
<li>
普通文件，文件长度可以是0， 在读这种文件时，将得到文件结束（end-of-file）指示 </li>
<li>
目录文件，文件长度常是一个数（例如16或512）的倍数 </li>
<li>
符号链接文件，文件长度是文件名中的实际字节数 </li>
</ul>
</td></tr>
<tr>
<td>9</td><td>类型：time_t &mdash;&gt;&gt; 名称：<b>st_atime</b></td><td>time of last access<br />
<br />
cat 会修改这个访问时间戳， 当然修改类的操作也会修改这个时间<br />
  </td></tr>
<tr>
<td>10</td><td>类型：time_t &mdash;&gt;&gt; 名称：<b>st_mtime</b></td><td>time of modification  </td></tr>
<tr>
<td>11</td><td>类型：time_t &mdash;&gt;&gt; 名称：<b>st_ctime</b></td><td>time of last file status change </td></tr>
<tr>
<td>12</td><td>类型：blksize_t &mdash;&gt;&gt; 名称：<b>st_blksize</b></td><td>best I/O block size  </td></tr>
<tr>
<td>13</td><td>类型：blkcnt_t &mdash;&gt;&gt; 名称：<b>st_blocks</b></td><td>number of disk blocks allocated </td></tr>
</table>
<a class="anchor" id=""></a>
<table class="doxtable">
<caption>文件类型</caption>
<tr>
<th width="40">序号</th><th>类型</th><th>概述 </th></tr>
<tr>
<td>1</td><td><b>普通文件</b>(regular file)</td><td><ul>
<li>
常用文件类型</li>
<li>
内核不区分文件的数据形式(文本或二进制)</li>
<li>
文件数据内容的解释由处理该文件的应用程序负责</li>
<li>
测试宏，S_ISREG()</li>
</ul>
</td></tr>
<tr>
<td>2</td><td><b>目录文件</b>(directory file)</td><td><ul>
<li>
包含目录下的文件名字及文件信息有关指针</li>
<li>
对目录有读权限的进程都可读目录，但只有内核可以直接写目录文件</li>
<li>
进程必须使用特定的函数才能更改目录</li>
<li>
测试宏，S_ISDIR()</li>
</ul>
</td></tr>
<tr>
<td>3</td><td><b>块特殊文件</b>(block special file)</td><td><ul>
<li>
提供对设备带缓冲的访问</li>
<li>
每次访问以固定长度为单位</li>
<li>
测试宏，S_ISBLK()</li>
</ul>
</td></tr>
<tr>
<td>4</td><td><b>字符特殊文件</b>(character special file)</td><td><ul>
<li>
提供对设备不带缓冲区的访问</li>
<li>
每次访问长度可变</li>
<li>
系统中设备要么是字符特殊文件，要么是块特殊文件</li>
<li>
测试宏，S_ISCHR()</li>
</ul>
</td></tr>
<tr>
<td>5</td><td><b>命名管道</b>(FIFO)</td><td><ul>
<li>
用于进程间通信</li>
<li>
测试宏，S_ISFIFO()</li>
</ul>
</td></tr>
<tr>
<td>6</td><td><b>套接字</b>(socket)</td><td><ul>
<li>
用于进程间的网络通信</li>
<li>
一台宿主机上进程间的非网络通信</li>
<li>
测试宏，S_ISSOCK()</li>
</ul>
</td></tr>
<tr>
<td>7</td><td><b>符号链接</b>(symbolic link)</td><td><ul>
<li>
指向另一个文件</li>
<li>
测试宏，S_ISLNK()</li>
</ul>
</td></tr>
</table>
<a class="anchor" id=""></a>
<table class="doxtable">
<caption>文件访问权限</caption>
<tr>
<th width="40">序号</th><th width="40">分类</th><th width="100">st_mode屏蔽</th><th>描述 </th></tr>
<tr>
<td>1</td><td rowspan="3">用户</td><td>S_IRUSR</td><td>用户-读 </td></tr>
<tr>
<td>2</td><td>S_IWUSR</td><td>用户-写 </td></tr>
<tr>
<td>3</td><td>S_IXUSR</td><td>用户-执行 </td></tr>
<tr>
<td>4</td><td rowspan="3">组</td><td>S_IRGRP</td><td>组-读 </td></tr>
<tr>
<td>5</td><td>S_IWGRP</td><td>组-写 </td></tr>
<tr>
<td>6</td><td>S_IXGRP</td><td>组-执行 </td></tr>
<tr>
<td>7</td><td rowspan="3">其他</td><td>S_IROTH</td><td>其他-读 </td></tr>
<tr>
<td>8</td><td>S_IWOTH</td><td>其他-写 </td></tr>
<tr>
<td>9</td><td>S_IXOTH</td><td>其他-执行 </td></tr>
<tr>
<td colspan="4"><b>补充说明</b> </td></tr>
<tr>
<td colspan="4"><ul>
<li>
我们用名字打开任一类型的文件时，对文件路径上的所有目录都必须具有执行权限，目录执行权限位常被称为搜索位的原因。<br />
目录的读权限和执行权限的差异性<br />
1.读权限允许我们读目录，获得在该目录中所有文件名的列表；<br />
2.当要访问目录下的一个文件，对该目录的执行权限使得可以通过该目录，找到特定的文件名。</li>
<li>
一个文件的读权限决定了我们是否能够打开该文件进行读操作，这与open函数的O_RDONLY和O_RDWR标志相关</li>
<li>
一个文件的写权限决定了我们是否能够打开该文件进行写操作，这与open函数的O_WRONLY和O_RDWR标志相关。</li>
<li>
当在open函数中对一个文件制定O_TRUNC标志，必须对该文件具有写权限</li>
<li>
当想在一个目录中创建一个新文件，必须对该目录具有写权限和执行权限</li>
<li>
当想删除一个文件，必须对包含该文件的目录具有写权限和执行权限，对该文件本身则不需要有读、写权限</li>
<li>
若用6个exec函数中的任何一个执行某个文件，都必须对该文件具有执行权限，该文件还必须是一个普通文件</li>
</ul>
当我们每次打开、创建或删除一个文件时，内核都会进行文件权限的测试，这种测试可能会涉及到2个所有者ID（文件的性质）和2个有效ID（进程的性质），内核测试的过程如下：<ol>
<li>
若进程的有效用户ID为0（超级用户），则允许访问</li>
<li>
若进程的有效用户ID等于文件的所有者ID（也就是该进程拥有此文件），若所有者适当的访问权限位被设置，则允许访问，否则拒绝访问</li>
<li>
若进程的有效组ID或进程的附加组ID之一等于文件的组ID，那么，如果适当的访问权限位被设置，则允许访问，否则拒绝访问</li>
<li>
若其他用户适当的访问权限位被设置，则允许访问，否则拒绝访问</li>
</ol>
</td></tr>
</table>
<a class="anchor" id=""></a>
<table class="doxtable">
<caption>与每个进程相关联的用户ID和组ID</caption>
<tr>
<th width="40">序号</th><th width="300">名称</th><th>描述 </th></tr>
<tr>
<td>1</td><td>实际用户ID</td><td rowspan="2">我们实际上是谁<br />
 用户登录时取自口令文件中的登录项<br />
登录期间一般不改变，但超级用户进程能改变它们 </td></tr>
<tr>
<td>2</td><td>实际组ID </td></tr>
<tr>
<td>3</td><td>有效用户ID</td><td rowspan="3">用于文件访问权限检查，决定了我们的文件访问权限 </td></tr>
<tr>
<td>4</td><td>有效组ID </td></tr>
<tr>
<td>5</td><td>附加组ID </td></tr>
<tr>
<td>6</td><td>保存的设置用户ID</td><td rowspan="2">由exec函数保存 </td></tr>
<tr>
<td>7</td><td>保存的设置组ID </td></tr>
<tr>
<td colspan="3"><b>补充说明</b> </td></tr>
<tr>
<td colspan="3"><ul>
<li>
一般地，有效用户ID等于实际用户ID，有效组ID等于实际组ID</li>
<li>
当执行一个可执行文件时，进程的有效用户ID、有效组ID通常就是对应的实际用户ID和实际组ID。<br />
俗话说万事都有例外，在文件模式字（st_mode）有那么两位分别为设置用户ID（set-user-ID）位和设置组ID（set-groupID ）位。<br />
它们的作用是，当执行此程序文件时，将进程的有效用户ID或有效组ID 设置为文件所有者的用户ID（st_uid）或文件的组所有者ID（st_gid）</li>
<li>
举个栗子，若文件所有者是超级用户，而且设置了该文件的设置用户ID位， 然后当该程序由一个进程执行时，则该进程具有超级用户权限。不管执行此文件的进程的进程的实际用户ID是什么，都进行这种处理。像passwd程序，允许任意用户改变其口令，它就是一个设置用户ID程序。<br />
-rwsr-xr-x. 1 root root 27832 Jun 10 2014 /usr/bin/passwd </li>
<li>
就像上面描述的一样，因为运行设置用户ID程序的进程通常得到额外的权限，所以编写这种程序时要特别谨慎。</li>
</ul>
</td></tr>
</table>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>文件路径 </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c04__dir_8cc_source.html">c04_dir.cc</a> 第 <a class="el" href="c04__dir_8cc_source.html#l00150">150</a> 行定义.</p>

</div>
</div>
<a id="a31c087d773da51b0ea4c026b1d6228f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c087d773da51b0ea4c026b1d6228f7">&#9670;&nbsp;</a></span>test_symlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_symlink </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>actualpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sympath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试symlink函数 </p>
<p>符号链接，是指一个文件的间接指针，它和硬链接不同，硬链接直接指向文件的i节点，引入符号链接的原因是为了避开硬链接的限制 </p><ol>
<li>
硬链接通常要求链接和文件位于同一文件系统中 </li>
<li>
只有超级用户才能创建指向目录的硬链接 </li>
</ol>
<p>对于符号链接以及它指向何种对象并无任何文件系统限制，任何用户都可创建指向目录的符号链接。符号链接一般用于将一个文件或整个目录结构移到系统中的另一个位置。<br />
 <br />
 当使用以名字应用文件的函数时，需要了解函数是否处理符号链接，也就是函数是否跟谁符号链接到达它所链接的文件。如果函数具有处理符号链接的功能，则其路径名参数引用由符号链接指向的文件。否则，路径名参数将引用链接本身，而不是链接指向的文件。 </p><a class="anchor" id=""></a>
<table class="doxtable">
<caption></caption>
<tr>
<th width="40">序号</th><th width="50">函数</th><th width="120">跟随符号链接</th><th width="400">说明 </th></tr>
<tr>
<td>1</td><td>access</td><td>是</td><td></td></tr>
<tr>
<td>2</td><td>chdir</td><td>是</td><td></td></tr>
<tr>
<td>3</td><td>chmod</td><td>是</td><td></td></tr>
<tr>
<td>4</td><td>chown</td><td>是<b>/否</b></td><td></td></tr>
<tr>
<td>5</td><td>creat</td><td>是</td><td></td></tr>
<tr>
<td>6</td><td>exec</td><td>是</td><td></td></tr>
<tr>
<td>7</td><td>lchown</td><td><b>/否</b></td><td></td></tr>
<tr>
<td>8</td><td>link</td><td>是</td><td></td></tr>
<tr>
<td>9</td><td>lstat</td><td><b>/否</b></td><td></td></tr>
<tr>
<td>10</td><td>open</td><td>是</td><td>用open打开文件时，如果传递给open函数的路径名指定了一个符号链接，那么open跟随此链接到达你所指定的文件。若此符号链接所指定的文件并不存在，则open返回出错，表示它不能打开该文件。 </td></tr>
<tr>
<td>11</td><td>opendir</td><td>是</td><td></td></tr>
<tr>
<td>12</td><td>pathconf</td><td>是</td><td></td></tr>
<tr>
<td>13</td><td>readlink</td><td><b>/否</b></td><td>如果传递给readlink函数的文件不是符号链接文件，则函数会返回出错readlink failed(Invalid argument) </td></tr>
<tr>
<td>14</td><td>remove</td><td><b>/否</b></td><td></td></tr>
<tr>
<td>15</td><td>stat</td><td>是</td><td></td></tr>
<tr>
<td>16</td><td>truncate</td><td>是</td><td></td></tr>
<tr>
<td>17</td><td>unlink</td><td><b>/否</b></td><td></td></tr>
</table>
<p><br />
</p>
<p><code> int symlink(const char *actualpath, const char *sympath);</code></p>
<p><code>返回值：成功则返回0， 出错则返回-1</code></p>
<p><code>ssize_t readlink(const char *restrict pathname, char *restrict buf, size_t bufsize);</code></p>
<p><code>返回值：成功则返回读到的字节数， 出错则返回-1 </code> </p><dl class="section warning"><dt>警告</dt><dd>symlink函数创建一个指向actualpath的新目录项sympath，在创建此符号链接时，并不要求actualpath已经存在，并且，actualpath和sympath并不需要位于同一文件系统中。<br />
 </dd>
<dd>
readlink函数提供一种方法打开该链接本身，并读该链接中的名字。该函数组合了open、read和close的所有操作，如果函数成功执行，则它返回读入buf的字节数，在buf中返回的符号链接的内容不以null字符终止。<br />
 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actualpath</td><td>待创建符号链接的文件 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sympath</td><td>创建的符号链接文件 </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c04__dir_8cc_source.html">c04_dir.cc</a> 第 <a class="el" href="c04__dir_8cc_source.html#l00676">676</a> 行定义.</p>

</div>
</div>
<a id="a47c9e8ec3a5362e3d890253ec5271937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c9e8ec3a5362e3d890253ec5271937">&#9670;&nbsp;</a></span>test_truncate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_truncate </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试truncate函数 </p>
<p><code> int truncate(const char *pathname, off_t length);</code></p>
<p><code>int ftruncate(int filedes, off_t length);</code></p>
<p><code>返回值：若成功则返回0， 若出错则返回-1 </code> </p><ul>
<li>
若该文件以前的长度大于length，则超过length以外的数据就不能访问 </li>
<li>
若该文件以前的长度短语length，则效果与系统有关 </li>
</ul>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>文件名 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>截取的长度 </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c04__dir_8cc_source.html">c04_dir.cc</a> 第 <a class="el" href="c04__dir_8cc_source.html#l00525">525</a> 行定义.</p>

</div>
</div>
<a id="aae8eeda87f82af599a06958b405f3790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8eeda87f82af599a06958b405f3790">&#9670;&nbsp;</a></span>test_umask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_umask </td>
          <td>(</td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>cmask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试umask函数 </p>
<p><code> mode_t umask(mode_t cmask);</code></p>
<p><code>返回值：以前的文件模式创建屏蔽字，函数没有出错返回 </code> </p><ul>
<li>
一般进程不设置umask值，它由shell启动文件设置，然后不改变 </li>
<li>
当编写创建新文件的程序时，若想确保指定的访问权限位已经激活，则必须在进程运行时修改umask值<br />
 将umask设置为0，确保任何用户都能读文件，否则，当进程运行时，有效的umask值可能关闭该权限位 </li>
</ul>
<a class="anchor" id=""></a>
<table class="doxtable">
<caption>umask文件访问权限位</caption>
<tr>
<th width="40">序号</th><th width="40">分类</th><th width="150">屏蔽位(八进制)</th><th>描述 </th></tr>
<tr>
<td>1</td><td rowspan="3">用户</td><td>0400</td><td>用户-读 </td></tr>
<tr>
<td>2</td><td>0200</td><td>用户-写 </td></tr>
<tr>
<td>3</td><td>0100</td><td>用户-执行 </td></tr>
<tr>
<td>4</td><td rowspan="3">组</td><td>0040</td><td>组-读 </td></tr>
<tr>
<td>5</td><td>0020</td><td>组-写 </td></tr>
<tr>
<td>6</td><td>0010</td><td>组-执行 </td></tr>
<tr>
<td>7</td><td rowspan="3">其他</td><td>0004</td><td>其他-读 </td></tr>
<tr>
<td>8</td><td>0002</td><td>其他-写 </td></tr>
<tr>
<td>9</td><td>0001</td><td>其他-执行 </td></tr>
</table>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmask</td><td>文件访问权限位 </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c04__dir_8cc_source.html">c04_dir.cc</a> 第 <a class="el" href="c04__dir_8cc_source.html#l00324">324</a> 行定义.</p>

</div>
</div>
<a id="a051b0c75489f39c54876853a03066c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051b0c75489f39c54876853a03066c12">&#9670;&nbsp;</a></span>test_utime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_utime </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试utime函数 </p>
<a class="anchor" id=""></a>
<table class="doxtable">
<caption>每个文件相关的三个时间值</caption>
<tr>
<th width="20">序号</th><th width="40">字段</th><th>说明 </th></tr>
<tr>
<td>1</td><td>st_atime</td><td>文件数据的最后访问时间，可以用 ls -u 命令显示查看， read函数可以修改该值 </td></tr>
<tr>
<td>2</td><td>st_mtime</td><td>文件数据的最后修改时间，可以用 ls 命令显示查看，write函数可以修改该值 </td></tr>
<tr>
<td>3</td><td>st_ctime</td><td>i节点状态的最后更改时间，可以用 ls -c 命令显示查看， chmod、chown函数可以修改该值 </td></tr>
</table>
<p><code> int utime(const char *pathname, const struct utimebuf *times);</code></p>
<p><code>返回值：成功返回0， 出错则返回-1</code></p>
<p><code>struct utimbuf{<br />
 time_t actime; // access time<br />
 time_t modtime; // modification time<br />
 };</code></p>
<p><code></code> 一个文件的访问和修改时间可以用utime函数更改， 此函数的操作以及执行它所要求的特权取决于times参数是否是NULL </p><ul>
<li>
如果times是一个空指针，则访问时间和修改时间两者都设置为当前时间。为了执行此操作必须满足下列两条件之一，进程的有效用户ID必须等于该文件的所有者ID，或者进程对该文件必须具有写权限 </li>
<li>
如果times是非空指针， 则访问时间和修改时间被设置为times所指向结构中的值，此时，进程的有效用户ID必须等于该文件的所有者ID，或者进程必须是一个超级用户进程，对文件只具有写权限是不够的 </li>
<li>
不能对更改状态时间st_ctime指定一个值，当调用utime函数时，此字段将自动更新 </li>
</ul>
<a class="anchor" id=""></a>
<table class="doxtable">
<caption>各种函数对访问、修改和更改状态时间的作用</caption>
<tr>
<th width="40" rowspan="2">序号</th><th width="150" rowspan="2">函数</th><th width="100" colspan="3">引用的文件或目录</th><th width="100" colspan="3">引用文件或目录所在父目录</th><th rowspan="2">说明 </th></tr>
<tr>
<th>a</th><th>m</th><th>c</th><th>a</th><th>m</th><th>c </th></tr>
<tr>
<td>1</td><td>chmod、fchmod</td><td></td><td></td><td>*</td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>2</td><td>chown、fchown</td><td></td><td></td><td>*</td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>3</td><td>creat</td><td>*</td><td>*</td><td>*</td><td></td><td>*</td><td>*</td><td>O_CREAT新文件 </td></tr>
<tr>
<td>4</td><td>creat</td><td></td><td>*</td><td>*</td><td></td><td></td><td></td><td>O_TRUNC现有文件 </td></tr>
<tr>
<td>5</td><td>exec</td><td>*</td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>6</td><td>lchown</td><td></td><td></td><td>*</td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>7</td><td>link</td><td></td><td></td><td>*</td><td></td><td>*</td><td>*</td><td>第二个参数的父目录 </td></tr>
<tr>
<td>8</td><td>mkdir</td><td>*</td><td>*</td><td>*</td><td></td><td>*</td><td>*</td><td></td></tr>
<tr>
<td>9</td><td>mkfifo</td><td>*</td><td>*</td><td>*</td><td></td><td>*</td><td>*</td><td></td></tr>
<tr>
<td>10</td><td>open</td><td>*</td><td>*</td><td>*</td><td></td><td>*</td><td>*</td><td>O_CREAT新文件 </td></tr>
<tr>
<td>11</td><td>open</td><td></td><td>*</td><td>*</td><td></td><td></td><td></td><td>O_TRUNC现有文件 </td></tr>
<tr>
<td>12</td><td>pipe</td><td>*</td><td>*</td><td>*</td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>13</td><td>read</td><td>*</td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>14</td><td>remove</td><td></td><td></td><td>*</td><td></td><td>*</td><td>*</td><td>删除文件=unlink </td></tr>
<tr>
<td>15</td><td>remove</td><td></td><td></td><td></td><td></td><td>*</td><td>*</td><td>删除目录=rmdir </td></tr>
<tr>
<td>16</td><td>rename</td><td></td><td></td><td>*</td><td></td><td>*</td><td>*</td><td>对于两个参数 </td></tr>
<tr>
<td>17</td><td>rmdir</td><td></td><td></td><td></td><td></td><td>*</td><td>*</td><td></td></tr>
<tr>
<td>18</td><td>truncate、ftruncate</td><td></td><td>*</td><td>*</td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>19</td><td>unlink</td><td></td><td></td><td>*</td><td></td><td>*</td><td>*</td><td></td></tr>
<tr>
<td>20</td><td>utime</td><td>*</td><td>*</td><td>*</td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>21</td><td>write</td><td></td><td>*</td><td>*</td><td></td><td></td><td></td><td></td></tr>
</table>
<dl class="section warning"><dt>警告</dt><dd>系统并不保存对一个i节点的最后一次访问时间， 所以access和stat函数并不更改这三个时间中的任一个。 </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>文件名称 </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c04__dir_8cc_source.html">c04_dir.cc</a> 第 <a class="el" href="c04__dir_8cc_source.html#l00771">771</a> 行定义.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
