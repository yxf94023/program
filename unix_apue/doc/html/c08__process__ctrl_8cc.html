<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>unix_apue: E:/git_thub/program/unix_apue/code/c08_process_ctrl/c08_process_ctrl.cc 文件参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">unix_apue
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','搜索');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_f0cb5942dd0816ee93f92f929c016bf6.html">c08_process_ctrl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">函数</a>  </div>
  <div class="headertitle">
<div class="title">c08_process_ctrl.cc 文件参考</div>  </div>
</div><!--header-->
<div class="contents">

<p>练习进程控制  
<a href="#details">更多...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;sys/wait.h&gt;</code><br />
<code>#include &lt;sys/times.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
</div>
<p><a href="c08__process__ctrl_8cc_source.html">浏览源代码.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:ac7d808308a607f9f88daefa8550f1fa1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c08__process__ctrl_8cc.html#ac7d808308a607f9f88daefa8550f1fa1">test_id</a> ()</td></tr>
<tr class="memdesc:ac7d808308a607f9f88daefa8550f1fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试进程id函数  <a href="#ac7d808308a607f9f88daefa8550f1fa1">更多...</a><br /></td></tr>
<tr class="separator:ac7d808308a607f9f88daefa8550f1fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dbf7271a851814757e98b3056ba559f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c08__process__ctrl_8cc.html#a3dbf7271a851814757e98b3056ba559f">test_fork</a> ()</td></tr>
<tr class="memdesc:a3dbf7271a851814757e98b3056ba559f"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试fork函数  <a href="#a3dbf7271a851814757e98b3056ba559f">更多...</a><br /></td></tr>
<tr class="separator:a3dbf7271a851814757e98b3056ba559f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526dbd4cbd53eec6434e11fcbed2acaf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c08__process__ctrl_8cc.html#a526dbd4cbd53eec6434e11fcbed2acaf">test_wait</a> ()</td></tr>
<tr class="memdesc:a526dbd4cbd53eec6434e11fcbed2acaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试wait函数  <a href="#a526dbd4cbd53eec6434e11fcbed2acaf">更多...</a><br /></td></tr>
<tr class="separator:a526dbd4cbd53eec6434e11fcbed2acaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf55ef41c3ebaa1f371330333957fb2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c08__process__ctrl_8cc.html#aeaf55ef41c3ebaa1f371330333957fb2">test_waitid</a> ()</td></tr>
<tr class="memdesc:aeaf55ef41c3ebaa1f371330333957fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试waitid函数  <a href="#aeaf55ef41c3ebaa1f371330333957fb2">更多...</a><br /></td></tr>
<tr class="separator:aeaf55ef41c3ebaa1f371330333957fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d305113852a4cc97a7a77b3071564bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c08__process__ctrl_8cc.html#a6d305113852a4cc97a7a77b3071564bb">test_exec</a> ()</td></tr>
<tr class="memdesc:a6d305113852a4cc97a7a77b3071564bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试exec函数  <a href="#a6d305113852a4cc97a7a77b3071564bb">更多...</a><br /></td></tr>
<tr class="separator:a6d305113852a4cc97a7a77b3071564bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4031696c16b84a47e1b408923c47757"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c08__process__ctrl_8cc.html#ab4031696c16b84a47e1b408923c47757">test_times</a> (const char *cmd)</td></tr>
<tr class="memdesc:ab4031696c16b84a47e1b408923c47757"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试times函数  <a href="#ab4031696c16b84a47e1b408923c47757">更多...</a><br /></td></tr>
<tr class="separator:ab4031696c16b84a47e1b408923c47757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c04138a5bfe5d72780bb7e82a18e627"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c08__process__ctrl_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> (int argc, char **argv)</td></tr>
<tr class="separator:a3c04138a5bfe5d72780bb7e82a18e627"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>练习进程控制 </p>
<dl class="section date"><dt>日期</dt><dd>2017/10/02 </dd></dl>

<p class="definition">在文件 <a class="el" href="c08__process__ctrl_8cc_source.html">c08_process_ctrl.cc</a> 中定义.</p>
</div><h2 class="groupheader">函数说明</h2>
<a id="a3c04138a5bfe5d72780bb7e82a18e627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c04138a5bfe5d72780bb7e82a18e627">&#9670;&nbsp;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="c08__process__ctrl_8cc_source.html">c08_process_ctrl.cc</a> 第 <a class="el" href="c08__process__ctrl_8cc_source.html#l00512">512</a> 行定义.</p>

</div>
</div>
<a id="a6d305113852a4cc97a7a77b3071564bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d305113852a4cc97a7a77b3071564bb">&#9670;&nbsp;</a></span>test_exec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_exec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试exec函数 </p>
<p><code> </p><pre class="fragment">int execl(const char *pathname, const char *arg0, ..., (char*)0);
int execv(const char *pathname, char *const argv[]);
int execle(const char *pathname, const char *arg0, ..., (char*)0, char *const envp[]);
int execve(const char *pathname, char *const argv[], char *const envp[]);
int execlp(const char *filename, const char *arg0, ..., (char*)0);
int execvp(const char *filename, char *const argv[]);

返回值：若出错返回-1， 若成功则不返回值
</pre><p> </code> 当进程调用一种exec函数时，该进程执行的程序完全替换为新程序，而新程序则从其main函数开始执行，因为调用exec并不创建新进程，所以前后的进程ID并未改变，exec指示用一个全新的程序替换了当前进程的正文、数据、堆和栈段<br />
 </p><ol>
<li>
在这一系列的exec函数中， 前4个取路径名作为参数，后两个则取文件名作为参数 <ul>
<li>
如果filename中包含/，则将其视为路径名</li>
<li>
否则就按PATH环境变量，在它所指定的各个目录中搜寻可执行文件</li>
</ul>
</li>
<li>
在这一系列的exec函数中， 传递参数的方式是不同的，函数名中含有l的要求每个命令行参数都说明为一个单独的参数。函数名中含有v的在传递参数时，需要先构造一个指向各参数的指针数组，然后将该数组地址作为这位函数的参数 </li>
<li>
在这一系列的exec函数中，向新程序传递环境表存在差异，以e结尾的两个函数可以传递一个指向环境字符串指针数组的指针， 其他四个函数则使用调用进程中的environ变量为新程序复制现有的环境 </li>
</ol>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c08__process__ctrl_8cc_source.html">c08_process_ctrl.cc</a> 第 <a class="el" href="c08__process__ctrl_8cc_source.html#l00378">378</a> 行定义.</p>

</div>
</div>
<a id="a3dbf7271a851814757e98b3056ba559f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dbf7271a851814757e98b3056ba559f">&#9670;&nbsp;</a></span>test_fork()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_fork </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试fork函数 </p>
<p><code> </p><pre class="fragment">pid_t fork(void)

返回值：子进程中返回0， 父进程中返回子进程ID， 出错返回-1
</pre><p></code></p>
<p><code></code> </p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>父子进程关联性分析</caption>
<tr>
<th width="60">序号</th><th width="100">关联性操作</th><th>说明 </th></tr>
<tr>
<td>1</td><td>fork返回值</td><td><ul>
<li>
将子进程ID返回给父进程的理由是，一个进程的子进程可以有多个，并且没有一个函数使一个进程可以获得其所有子进程的进程ID</li>
<li>
子进程得到返回值0的理由是，一个进程只会有一个父进程，所以子进程总是可以调用getppid以获得其父进程的进程ID</li>
</ul>
</td></tr>
<tr>
<td>2</td><td>写时复制技术</td><td>子进程和父进程继续执行fork调用之后的指令，子进程是父进程的副本（子进程获得父进程数据空间、堆和栈的副本），这是子进程所拥有的副本。<br />
父、子进程并不共享这些存储空间部分。父、子进程共享正文段。<br />
由于在fork之后经常跟随者exec，所以现在的很多实现并不执行一个父进程数据段、栈和堆的完全复制，作为替代，使用了写时复制（Copy-On-Write, COW)技术。<br />
这些区域由父、子进程共享，而且内核将它们的访问权限改变为只读的，如果父、子进程中的任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储器系统中的一“页” </td></tr>
<tr>
<td>3</td><td>文件共享</td><td>在重定向父进程的标准输出时，子进程的标准输出也被重定向。<br />
实际上，fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中，父、子进程的每个相同的打开描述符共享一个文件表项。<br />
这种共享文件的方式使父、子进程对同一文件使用了一个文件偏移量。在fork之后处理文件描述符有两种常见的情况：<ul>
<li>
父进程等待子进程完成，在这种情况下，父进程无需对其描述符做任何处理，当子进程终止后，它曾进行过读、写操作的任一共享描述符的文件偏移量已执行了相应更新</li>
<li>
父、子进程各自执行不同的程序段，在这种情况下，在fork之后，父、子进程各自关闭它们不需使用的文件描述符，这样就不会干扰对方使用的文件描述符，这种方法是网络服务进程中经常使用的</li>
</ul>
</td></tr>
<tr>
<td>4</td><td>继承属性</td><td><ol>
<li>
实际用户ID、实际组ID、 有效用户ID、 有效组ID</li>
<li>
附加组ID</li>
<li>
进程组ID</li>
<li>
会话ID</li>
<li>
控制终端</li>
<li>
设置用户ID标志和设置组ID标志</li>
<li>
当前工作目录</li>
<li>
根目录</li>
<li>
文件模式创建屏蔽字</li>
<li>
信号屏蔽和安排</li>
<li>
针对任一打开文件描述符的在执行时关闭(close-on-exec)标志</li>
<li>
环境</li>
<li>
连接的共享存储段</li>
<li>
存储映射</li>
<li>
资源限制</li>
</ol>
</td></tr>
<tr>
<td>5</td><td>差异属性</td><td><ol>
<li>
fork的返回值</li>
<li>
进程ID不同</li>
<li>
两个进程具有不同的父进程ID</li>
<li>
子进程的tms_utime、tms_stime、tms_cutime以及tms_ustime均被设置为0</li>
<li>
父进程设置的文件锁不会被子进程继承</li>
<li>
子进程的未处理的闹钟(alarm)被清除</li>
<li>
子进程的未处理信号集设置为空集</li>
</ol>
</td></tr>
</table>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c08__process__ctrl_8cc_source.html">c08_process_ctrl.cc</a> 第 <a class="el" href="c08__process__ctrl_8cc_source.html#l00094">94</a> 行定义.</p>

</div>
</div>
<a id="ac7d808308a607f9f88daefa8550f1fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d808308a607f9f88daefa8550f1fa1">&#9670;&nbsp;</a></span>test_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试进程id函数 </p>
<ol type="1">
<li>每个进程都有一个非负整型表示的唯一进程ID<br />
</li>
<li>进程ID是可以重用，当一个进程终止后，其进程ID就可以再次使用了，大多数UNIX系统实现延迟重用算法，使得赋予新进程的ID不同于最近终止进程所使用的ID。<br />
</li>
<li>ID为0的进程通常是调度进程，常常被称为交换进程（swapper），该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。<br />
</li>
<li>ID为1的通常是init进程，在自举过程结束时由内核调用，init进程不会终止，它是一个普通的用户进程，但是它以超级用户特权运行<br />
</li>
<li>每个UNIX系统实现都有它自己的一套提供操作系统服务的内核进程，例如，在某些UNIX的虚拟存储器实现中，进程ID2是页守护进程（pagedaemon），它负责支持虚拟存储系统的分页操作<br />
</li>
</ol>
<p><code> </p><pre class="fragment">pid_t getpid(void)
返回值：调用进程的进程ID

pid_t getppid(void)
返回值：调用进程的父进程ID

pid_t getuid(void)
返回值：调用进程的实际用户ID

pid_t geteuid(void)
返回值：调用进程的有效用户ID

pid_t getgid(void)
返回值：调用进程的实际组ID

pid_t getegid(void)
返回值：调用进程的有效组ID
</pre><p></code></p>
<p><code></code></p>
<dl class="section warning"><dt>警告</dt><dd>这些函数都没有出错返回</dd></dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c08__process__ctrl_8cc_source.html">c08_process_ctrl.cc</a> 第 <a class="el" href="c08__process__ctrl_8cc_source.html#l00051">51</a> 行定义.</p>

</div>
</div>
<a id="ab4031696c16b84a47e1b408923c47757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4031696c16b84a47e1b408923c47757">&#9670;&nbsp;</a></span>test_times()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_times </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试times函数 </p>
<p><code> </p><pre class="fragment">clock_t times(struct tms *buf);

返回值：若成功则返回流逝的墙上时钟时间（单位，时钟滴答数），若出错则返回-1

struct tms{
     clock_t    tms_utime;  // user CPU time
     clock_t    tms_stime;  // system CPU time
     clock_t    tms_cutime; // user CPU time, terminated children
     clock_t    tms_cstime; // system CPU time, terminated children
};
</pre><p> </code></p>
<ol>
<li>
任一进程都可调用times函数已获得它自己及已终止子进程的 墙上时钟时间、用户CPU时间和系统CPU时间  </li>
<li>
struct tms结构体中没有包含墙上时钟时间的任何测量值，作为替代， times函数返回墙上时钟时间作为其函数值。此值是相对于过去的某一时刻测量的， 所以不能用其绝对值， 而必须使用其相对值  </li>
<li>
所有由此函数返回的clock_t值都用_SC_CLK_TCK(由sysconf函数返回的每秒时钟滴答数)变换成秒数</li>
</ol>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>执行的命令用于system调用</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c08__process__ctrl_8cc_source.html">c08_process_ctrl.cc</a> 第 <a class="el" href="c08__process__ctrl_8cc_source.html#l00452">452</a> 行定义.</p>

</div>
</div>
<a id="a526dbd4cbd53eec6434e11fcbed2acaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526dbd4cbd53eec6434e11fcbed2acaf">&#9670;&nbsp;</a></span>test_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试wait函数 </p>
<a class="anchor" id=""></a>
<table class="doxtable">
<caption>进程终止 父子进程变化</caption>
<tr>
<th width="40">序号</th><th width="100">行为</th><th width="400">描述 </th></tr>
<tr>
<td>1</td><td>产生终止状态</td><td><ul>
<li>
不管进程如何终止， 最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开描述符，释放它所使用的存储器等</li>
<li>
对于任意一种终止情况(正常或异常)，我们都希望终止进程能够通知其父进程它是如何终止的。对于三个终止函数（exit、_exit和_Exit)，实现这一点的方法是， 将其推出状态作为参数传递给函数。在异常终止情况下，内核（不是进程本身）产生一个指示其异常终止原因的终止状态。在任意一种情况下，该终止进程的父进程都能用wait或waitpid函数取得其终止状态</li>
</ul>
</td></tr>
<tr>
<td>2</td><td>init领养子进程</td><td>对于父进程已经终止的所有进程，它们的父进程都改变为init进程，我们称这些进程由init进程领养，操作过程大致如下，在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则将该进程的父进程ID更改为1，这种处理方法保证了每个进程都有一个父进程 </td></tr>
<tr>
<td>3</td><td>产生僵死进程</td><td>子进程在父进程之前终止，那么父进程又如何能在做相应检查时得到子进程的终止状态？<br />
内核为每个终止进程保存了一定量的信息， 所以当终止进程的父进程调用wait或waitpid时，可以得到这些信息，这些信息至少包括进程ID、该进程的终止状态、以及该进程使用的CPU时间总量，内核可以释放终止进程所使用的所有存储区，关闭其所有打开文件。<br />
一个已经终止、但是其父进程尚未对其进行善后处理的进程被称为僵死进程（zombie）。如果编写一个长期运行的程序，它调用fork产生了很多子进程，那么除非父进程等待取得子进程的终止状态，否则这些子进程终止后就会变成僵死进程 </td></tr>
<tr>
<td>4</td><td>发送SIGCHLD信号</td><td>当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号，因为进程终止是个异步事件，所以这种信号也是内核向父进程发的异步通知。父进程可以选择忽略该信号， 或者提供一个信号处理函数， 对于这种信号系统的默认动作是忽略它 </td></tr>
</table>
<p><code> </p><pre class="fragment">pid_t wait(int *statloc);
pid_t waitpid(pid_t pid, int *statloc, int options);

返回值：若成功则返回进程ID，出错则返回-1
这两个函数的参数statloc是一个整型指针，
    如果statloc不是一个空指针，则终止进程的终止状态存放在它所指向的单元内，
    如果不关心终止状态， 则可将该参数指针定为空指针
</pre><p> </code></p>
<p>调用wait或waitpid的进程可能会发生的情况： </p><ol>
<li>
如果其所有子进程都还在运行，则阻塞 </li>
<li>
如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回 </li>
<li>
如果它没有任何子进程，则立即出错返回 </li>
</ol>
<p>这两个函数的区别如下： </p><ol>
<li>
在一个子进程终止前， wait使其调用者阻塞，而waitpid有一个选项，可使调用者不阻塞 </li>
<li>
waitpid并不等待在其调用之后的第一个终止子进程，它有若干个选项，可以控它所等待的进程 </li>
</ol>
<a class="anchor" id=""></a>
<table class="doxtable">
<caption>检查wait和waitpid所返回的终止状态宏</caption>
<tr>
<th width="40">序号</th><th width="100">宏</th><th>描述 </th></tr>
<tr>
<td>1</td><td>WIFEXITED(status)</td><td>若为正常终止子进程返回的状态，则为真<br />
对于这种情况可执行WEXITSTATUS(status)，取子进程传送给exit, _exit或_Exit参数的低8位 </td></tr>
<tr>
<td>2</td><td>WIFSIGNALED(status)</td><td>若为异常终止子进程返回的状态，则为真（接到一个不捕捉的信号）<br />
对于这种情况，可以执行WTERMSIG(status)，取得子进程终止的信号编号，另外，有些实现定义宏WCOREDUMP(status)，若已产生终止进程的core文件， 则它返回真 </td></tr>
<tr>
<td>3</td><td>WIFSTOPPED(status)</td><td>若为当前暂停子进程的返回的状态，则为真<br />
对于这种情况， 可执行WSTOPSIG(status)， 取得子进程暂停的型号编号 </td></tr>
<tr>
<td>4</td><td>WIFCONTINUED(status)</td><td>若在作业控制暂停后已经继续的子进程返回了状态， 则为真 </td></tr>
</table>
<p><br />
 </p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>waitpid函数中pid参数的作用</caption>
<tr>
<th width="40">序号</th><th width="100">值</th><th>说明 </th></tr>
<tr>
<td>1</td><td>pid == -1</td><td>等待任一子进程，就这一方面而言，waitpid与wait等效 </td></tr>
<tr>
<td>2</td><td>pid &gt; 0</td><td>等待其进程ID与pid相等的子进程 </td></tr>
<tr>
<td>3</td><td>pid == 0</td><td>等待其组ID等于调用进程组ID的任一子进程 </td></tr>
<tr>
<td>4</td><td>pid &lt; -1</td><td>等待其组ID等于pid绝对值的任一子进程 </td></tr>
</table>
<p><br />
 </p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>waitpid的options常量</caption>
<tr>
<th width="40">序号</th><th width="100">常量</th><th>描述 </th></tr>
<tr>
<td>1</td><td>WCONTINUED</td><td>若实现支持作业控制，那么由pid指定的任一子进程在暂停后已经继续，但其状态尚未报告，则返回其状态 </td></tr>
<tr>
<td>2</td><td>WNOHANG</td><td>若由pid指定的子进程并不是立即可用的，则waitpid不阻塞，此时其返回值为0 </td></tr>
<tr>
<td>3</td><td>WUNTRACED</td><td>若某实现支持作业控制，而由pid指定的任一子进程已处于暂停状态，并且其状态自暂停以来还未报告过，则返回其状态，WIFSTOPPED宏确定返回值是否对应于一个暂停子进程 </td></tr>
</table>
<p>waitpid函数返回终止子进程的进程ID，并将该子进程的终止状态存放在由statloc指向的存储单元中，对于wait，其唯一的出错是调用进程没有子进程（函数调用被一个信号中断时，也可能返回另一种出错），但是对于waitpid，如果指定的进程或进程组不存在，或者参数pid指定的进程不是调用进程的子进程则都将出错， waitpid函数提供了wait函数没有的三个功能： </p><ol>
<li>
waitpid可等待一个特定的进程，而wait则返回任一终止子进程的状态 </li>
<li>
waitpid提供了一个wait的非阻塞版本，有时用户希望取得一个子进程的状态，但不想阻塞 </li>
<li>
waitpid支持作业控制（利用WUNTRACED和WCONTINUED选项） </li>
</ol>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c08__process__ctrl_8cc_source.html">c08_process_ctrl.cc</a> 第 <a class="el" href="c08__process__ctrl_8cc_source.html#l00210">210</a> 行定义.</p>

</div>
</div>
<a id="aeaf55ef41c3ebaa1f371330333957fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf55ef41c3ebaa1f371330333957fb2">&#9670;&nbsp;</a></span>test_waitid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_waitid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试waitid函数 </p>
<p><code> </p><pre class="fragment">int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);

返回值：若成功则返回0， 若出错则返回-1
</pre><p></code></p>
<p><code></code></p>
<p>与waitpid相似， waitid允许一个进程指定要等待的子进程，但它使用单独的参数表示要等待的子进程的类型，而不是将此与进程ID或进程组ID组合成一个参数。 </p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>waitid的idtype常量</caption>
<tr>
<th width="40">序号</th><th width="100">常量</th><th>描述 </th></tr>
<tr>
<td>1</td><td>P_PID</td><td>等待一个特定的进程，id包含要等待子进程的进程ID </td></tr>
<tr>
<td>2</td><td>P_PGID</td><td>等待一个特定进程组中的任一子进程，id包含要等待子进程的进程组ID </td></tr>
<tr>
<td>3</td><td>P_ALL</td><td>等待任一子进程，忽略id </td></tr>
</table>
<p>options参数是下表中各标志的按位“或”，这些标志指示调用者关注那些状态变化 </p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>waitid的options常量</caption>
<tr>
<th width="40">序号</th><th width="100">常量</th><th>描述 </th></tr>
<tr>
<td>1</td><td>WCONTINUED</td><td>等待一个进程，它以前曾被暂停，此后又已继续，但其状态尚未报告 </td></tr>
<tr>
<td>2</td><td>WEXITED</td><td>等待已退出的进程 </td></tr>
<tr>
<td>3</td><td>WNOHANG</td><td>如无可用的子进程退出状态，立即返回而非阻塞 </td></tr>
<tr>
<td>4</td><td>WNOWAIT</td><td>不破坏子进程退出状态，该子进程退出状态可由后续的wait、waitid或waitpid调用取得 </td></tr>
<tr>
<td>5</td><td>WSTOPPED</td><td>等待一个进程，它已经暂停，但其状态尚未报告 </td></tr>
</table>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c08__process__ctrl_8cc_source.html">c08_process_ctrl.cc</a> 第 <a class="el" href="c08__process__ctrl_8cc_source.html#l00347">347</a> 行定义.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
