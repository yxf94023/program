<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>unix_apue: E:/git_thub/program/unix_apue/code/c15_process_ipc/c15_process_ipc.cc 文件参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">unix_apue
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','搜索');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_de359cc15a10a4aaa7a9cc50886d6547.html">c15_process_ipc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">函数</a>  </div>
  <div class="headertitle">
<div class="title">c15_process_ipc.cc 文件参考</div>  </div>
</div><!--header-->
<div class="contents">

<p>练习进程间通信  
<a href="#details">更多...</a></p>
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;fcntl.h&gt;</code><br />
<code>#include &lt;sys/stat.h&gt;</code><br />
<code>#include &lt;sys/wait.h&gt;</code><br />
<code>#include &lt;sys/resource.h&gt;</code><br />
<code>#include &lt;signal.h&gt;</code><br />
<code>#include &lt;ctype.h&gt;</code><br />
</div>
<p><a href="c15__process__ipc_8cc_source.html">浏览源代码.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:a194789efff726353c4feb3928f925e04"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c15__process__ipc_8cc.html#a194789efff726353c4feb3928f925e04">test_pipe</a> ()</td></tr>
<tr class="memdesc:a194789efff726353c4feb3928f925e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试pipe管道  <a href="#a194789efff726353c4feb3928f925e04">更多...</a><br /></td></tr>
<tr class="separator:a194789efff726353c4feb3928f925e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8265c87c9e9b40f1d6af85a506f417"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c15__process__ipc_8cc.html#a7d8265c87c9e9b40f1d6af85a506f417">test_popen</a> ()</td></tr>
<tr class="memdesc:a7d8265c87c9e9b40f1d6af85a506f417"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试popen管道  <a href="#a7d8265c87c9e9b40f1d6af85a506f417">更多...</a><br /></td></tr>
<tr class="separator:a7d8265c87c9e9b40f1d6af85a506f417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb9b8301cf8670f5f8611c39f27d85d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c15__process__ipc_8cc.html#a1fb9b8301cf8670f5f8611c39f27d85d">test_echo</a> ()</td></tr>
<tr class="memdesc:a1fb9b8301cf8670f5f8611c39f27d85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试利用管道进行回显功能  <a href="#a1fb9b8301cf8670f5f8611c39f27d85d">更多...</a><br /></td></tr>
<tr class="separator:a1fb9b8301cf8670f5f8611c39f27d85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c37794a3f45d1b970ca8a3081e388a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c15__process__ipc_8cc.html#a97c37794a3f45d1b970ca8a3081e388a">test_ipc_add</a> ()</td></tr>
<tr class="memdesc:a97c37794a3f45d1b970ca8a3081e388a"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试协同进程  <a href="#a97c37794a3f45d1b970ca8a3081e388a">更多...</a><br /></td></tr>
<tr class="separator:a97c37794a3f45d1b970ca8a3081e388a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaefed642406e32a5afb6c94bb55c5a7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c15__process__ipc_8cc.html#aaefed642406e32a5afb6c94bb55c5a7f">test_read_fifo</a> (const char *path)</td></tr>
<tr class="memdesc:aaefed642406e32a5afb6c94bb55c5a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试FIFO  <a href="#aaefed642406e32a5afb6c94bb55c5a7f">更多...</a><br /></td></tr>
<tr class="separator:aaefed642406e32a5afb6c94bb55c5a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ecea6db06cba13d53f4190c048a1d15"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c15__process__ipc_8cc.html#a9ecea6db06cba13d53f4190c048a1d15">test_write_fifo</a> (const char *path)</td></tr>
<tr class="separator:a9ecea6db06cba13d53f4190c048a1d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac66f3f6b31b64f76978bddad3c5eba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c15__process__ipc_8cc.html#aaac66f3f6b31b64f76978bddad3c5eba">test_xsi_ipc</a> ()</td></tr>
<tr class="memdesc:aaac66f3f6b31b64f76978bddad3c5eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">XSI IPC  <a href="#aaac66f3f6b31b64f76978bddad3c5eba">更多...</a><br /></td></tr>
<tr class="separator:aaac66f3f6b31b64f76978bddad3c5eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c04138a5bfe5d72780bb7e82a18e627"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="c15__process__ipc_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> (int argc, char **argv)</td></tr>
<tr class="separator:a3c04138a5bfe5d72780bb7e82a18e627"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>练习进程间通信 </p>
<dl class="section date"><dt>日期</dt><dd>2018/04/15 </dd></dl>

<p class="definition">在文件 <a class="el" href="c15__process__ipc_8cc_source.html">c15_process_ipc.cc</a> 中定义.</p>
</div><h2 class="groupheader">函数说明</h2>
<a id="a3c04138a5bfe5d72780bb7e82a18e627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c04138a5bfe5d72780bb7e82a18e627">&#9670;&nbsp;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="c15__process__ipc_8cc_source.html">c15_process_ipc.cc</a> 第 <a class="el" href="c15__process__ipc_8cc_source.html#l00536">536</a> 行定义.</p>

</div>
</div>
<a id="a1fb9b8301cf8670f5f8611c39f27d85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb9b8301cf8670f5f8611c39f27d85d">&#9670;&nbsp;</a></span>test_echo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_echo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试利用管道进行回显功能 </p>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c15__process__ipc_8cc_source.html">c15_process_ipc.cc</a> 第 <a class="el" href="c15__process__ipc_8cc_source.html#l00195">195</a> 行定义.</p>

</div>
</div>
<a id="a97c37794a3f45d1b970ca8a3081e388a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c37794a3f45d1b970ca8a3081e388a">&#9670;&nbsp;</a></span>test_ipc_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_ipc_add </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试协同进程 </p>
<p>UNIX系统过滤程序从标准输入读取数据，对其进行适当处理后写到标准输出。几个过滤程序通常在shell管道命令行中线性地连接。当一个程序产生某个过滤程序的输入， 同时又读取该过滤程序的输出时，则该过滤程序就成为协同进程。</p>
<p>popen只提供连接到另一个进程的标准输入或标准输出的一个单向管道，而对于协同进程，则它有连接到另一个进程的两个单向管道---&mdash;一个连到其标准输入，另一个则来自其标准输出。我们先要将数据写到其标准输入， 经其处理后， 再从其标准输出读取数据。</p>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c15__process__ipc_8cc_source.html">c15_process_ipc.cc</a> 第 <a class="el" href="c15__process__ipc_8cc_source.html#l00245">245</a> 行定义.</p>

</div>
</div>
<a id="a194789efff726353c4feb3928f925e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194789efff726353c4feb3928f925e04">&#9670;&nbsp;</a></span>test_pipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_pipe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试pipe管道 </p>
<p><code> #include &lt;unistd.h&gt;</code></p>
<p><code>int pipe(int filedes[2]);</code></p>
<p><code>返回值：若成功则返回0， 若出错则返回-1 </code></p>
<p>管道是由调用pipe函数而创建的， 经由参数filedes返回两个文件描述符：filedes[0]为读而打开，filedes[1]为写而打开，filedes[1]的输出时fildes[0]的输入。<br />
 fstat函数对管道的每一端都返回一个FIFO类型的文件描述符，可以用S_ISFIFO宏来测试管道。<br />
 </p><ol>
<li>
管道是UNIX系统IPC的最古老形式，并且所有UNIX系统都提供此种通信机制。历史上它是半双工的。现在，某些系统提供全双工管道，但是为了最佳的可移植性，我们绝不应预先假定系统使用此特性 </li>
<li>
管道只能在具有公共祖先的进程之间使用。通常，一个管道由一个进程创建，然后该进程调用fork，此后父、子进程之间就可应用该管道 </li>
</ol>
<p>尽管有上面2种局限性，半双工管道仍是最常用的IPC形式。每当你在管道线中键入一个由shell执行的命令序列时，shell为每一条命令单独创建一进程，然后将前一条命令进程的标准输出用管道与后一条命令的标准输入相连接。<br />
</p>
<p>单个进程中的管道几乎没有任何用处。通常，调用pipe的进程接着调用fork，这样就创建了从父进程到子进程（或反向）的IPC通道。调用fork后做什么取决于我们想要有的数据流的方向。对于父进程到子进程的管道，父进程关闭管道的读端（fd[0]），子进程关闭写端（fd[1]）；为了构造从子进程到父进程的管道，父进程关闭fd[1]，子进程关闭fd[0]。<br />
 当管道的一端被关闭后， 下列两条规则起作用： </p><ol>
<li>
当读一个写端已被关闭的管道时，在所有数据都被读取后，read返回0，以指示达到了文件结束处。 </li>
<li>
如果写一个读端已经关闭的管道，则产生信号SIGPIPE。如果忽略该信号或者捕捉该信号并从其处理程序返回，则write返回-1，errno设置为EPIPE。 </li>
</ol>
<dl class="section warning"><dt>警告</dt><dd>在写管道（或FIFO）时，常量PIPE_BUF规定了内核中管道缓冲区的大小。如果对管道调用write，而且要求写的字节数小于等于PIPE_BUF，则此操作不会与其他进程对同一管道（或FIFO）的write操作穿插进行。但是，若有多个进程同时写一个管道（或FIFO），而且有进程要求写的字节数超过PIPE_BUF字节数时，则写操作的数据可能相互穿插。用pathconf或fpathconf函数可以确定PIPE_BUF的值。</dd></dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c15__process__ipc_8cc_source.html">c15_process_ipc.cc</a> 第 <a class="el" href="c15__process__ipc_8cc_source.html#l00053">53</a> 行定义.</p>

</div>
</div>
<a id="a7d8265c87c9e9b40f1d6af85a506f417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8265c87c9e9b40f1d6af85a506f417">&#9670;&nbsp;</a></span>test_popen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_popen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试popen管道 </p>
<p><code> #include &lt;stdio.h&gt;</code></p>
<p><code>FILE *popen(const char *cmdstring, const char *type);</code></p>
<p><code>返回值：若成功则返回文件指针，若出错则返回NULL</code></p>
<p><code>int pclose(FILE *fp);</code></p>
<p><code>返回值：cmdstring的终止状态，若出错则返回-1 </code></p>
<p>标准I/O库提供了popen和pclose，这两个函数实现的操作是：创建一个管道，调用fork产生一个子进程， 关闭管道的不使用端，调用exec执行一个shell以运行命令，然后等待命令终止，并且返回一个标准I/O文件指针。 如果type是“r”，则文件指针连接到cmdstring的标准输出；如果type是“w”，则文件指针连接到cmdstring的标准输入。<br />
 pclose函数关闭标准I/O流，等待命令执行结束，然后返回shell的终止状态。如果shell不能被执行，则pclose返回的终止状态与shell已执行exit(127)一样。</p>
<dl class="section warning"><dt>警告</dt><dd>注意，popen绝不应由设置用户ID或设置组ID程序调用。当它执行命令时，popen等同于：execl("/bin/sh", "sh", "-c", command, NULL); 它在从调用者继承的环境中执行shell，并由shell解释执行command。一个心怀不轨的用户可以操纵这种环境，使得shell能以设置ID文件模式所授予的提升了的权限以及非预期的方式执行命令。 </dd></dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c15__process__ipc_8cc_source.html">c15_process_ipc.cc</a> 第 <a class="el" href="c15__process__ipc_8cc_source.html#l00129">129</a> 行定义.</p>

</div>
</div>
<a id="aaefed642406e32a5afb6c94bb55c5a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaefed642406e32a5afb6c94bb55c5a7f">&#9670;&nbsp;</a></span>test_read_fifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_read_fifo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>测试FIFO </p>
<p>FIFO有时称为命名管道。管道只能由相关进程使用， 这些相关进程的共同的祖先进程创建了管道。 但是， 通过FIFO，不相关的进程也能交换数据。</p>
<p>因为FIFO是一种文件类型， 所以， 创建FIFO类似于创建文件。</p>
<p><code> #include &lt;sys/stat.h&gt;</code></p>
<p><code>int mkfifo(const char *pathname, mode_t mode);</code></p>
<p><code></code></p>
<p>一旦已经用mkfifo创建了一个FIFO， 就可用open打开它。 其实， 一般的文件I/O函数（close，read，write，unlink等）都可用于FIFO</p>
<p>当打开一个FIFO时， 非阻塞标志（O_NONBLOCK）产生下列影响： </p><ol>
<li>
在一般情况中（没有指定O_NONBLOCK）， 只读open要阻塞到某个其他进程为写而打开此FIFO。类似地， 只写open要阻塞到某个其他进程为读而打开它 </li>
<li>
如果指定了O_NONBLOCK，则只读open立即返回。 但是， 如果没有进程已经为读而打开一个FIFO， 那么只写open将出错返回-1， 其errno是ENXIO </li>
</ol>
<p>类似于管道， 若用write写一个尚无进程为读而打开的FIFO， 则产生信号SIGPIPE。</p>
<p>一个给定的FIFO有多个写进程是很常见的。这意味着如果不希望多个进程所写的数据互相穿插， 则需考虑原子写操作。正如对于管道一样，常量PIPE_BUF说明了可被原子地写到FIFO的最大数据量。</p>
<p>FIFO有下面2种用途： </p><ol>
<li>
FIFO由shell命令使用以便将数据从一条管道线传送到另一条， 为此无需创建中间临时文件 </li>
<li>
FIFO用于客户进程-服务器进程应用程序中， 以在客户进程和服务器进程之间传递数据。 </li>
</ol>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>fifo文件名</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c15__process__ipc_8cc_source.html">c15_process_ipc.cc</a> 第 <a class="el" href="c15__process__ipc_8cc_source.html#l00407">407</a> 行定义.</p>

</div>
</div>
<a id="a9ecea6db06cba13d53f4190c048a1d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ecea6db06cba13d53f4190c048a1d15">&#9670;&nbsp;</a></span>test_write_fifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_write_fifo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="c15__process__ipc_8cc_source.html">c15_process_ipc.cc</a> 第 <a class="el" href="c15__process__ipc_8cc_source.html#l00443">443</a> 行定义.</p>

</div>
</div>
<a id="aaac66f3f6b31b64f76978bddad3c5eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac66f3f6b31b64f76978bddad3c5eba">&#9670;&nbsp;</a></span>test_xsi_ipc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_xsi_ipc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XSI IPC </p>
<p>有三种IPC我们称作XSI IPC， 即消息队列、信号量以及共享存储器，它们之间有很多相似之处。</p>
<p><code> #include &lt;sys/ipc.h&gt;</code></p>
<p><code> key_t ftok(const char *path, int id);</code></p>
<p><code> 若成功则返回键， 若出错则返回(key_t)-1;</code></p>
<p><code> </code> path参数必须引用一个现存文件。 当产生键时， 只使用id参数的低8位。 </p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>XSI IPC基本概念</caption>
<tr>
<th width="40">序号</th><th width="80">名字</th><th width="400">描述</th><th>对比 </th></tr>
<tr>
<td rowspan="3">01</td><td rowspan="3">标识符和键</td><td>每个内核中的IPC的结构（消息队列、信号量或共享存储段）都用一个非负整数的标识符加以引用。</td><td>当一个IPC结构被创建， 以后又被删除时， 与这种结构相关的标识符连续加1，直至达到一个整数的最大正值，然后又回转到0。 </td></tr>
<tr>
<td>标识符是IPC对象的内部名，为了使多个合作进程能够在同一IPC对象上会合，需要提供一个外部名方案。为此使用了键，每个IPC对象都与一个键相关联，于是键就用作为该对象的外部名</td><td>有多种方法使客户进程和服务器进程在同一IPC结构上会合： <ol>
<li>
服务器进程可以指定键IPC_PRIVATE创建一个新IPC结构，将返回的标识符存放在某处（例如一个文件）以便客户进程取用。键IPC_PRIVATE保证服务器进程创建一个新IPC结构。这种技术的缺点是：服务器进程要将整型标识符写到文件中，此后客户进程又要读文件取得此标识符。 </li>
<li>
在一个公用头文件中定义一个客户进程和服务器进程都认可的键。然后服务器进程指定此键创建一个新的IPC结构。这种方法的问题是该键可能已与一个IPC结构相结合，在此情况下， get函数（msgget、semget或shmget）出错返回。服务器进程必须处理这一错误，删除已存在的IPC结构，然后试着再创建它。 </li>
<li>
客户进程和服务器进程认同一个路径名和项目ID（项目ID是0~255之间的字符值），接着调用函数ftok将这两个值变换为一个键。然后在方法（2）中使用此键。ftok提供的唯一服务就是有一个路径名和项目ID产生一个键。 </li>
</ol>
</td></tr>
<tr>
<td>三个get函数（msgget、semget和shmget）都有两个类似的参数：一个key和一个整型flag。若满足下列两个条件之一，则创建一个新的IPC结构（通常由服务器进程创建） <ol>
<li>
key是IPC_PRIVATE </li>
<li>
key当前未与特定类型的IPC结构相结合，并且flag中指定了IPC_CREAT位 </li>
</ol>
</td><td>为访问现存的队列（通常由客户进程进行），key必须等于创建该队列时所指定的键， 并且不应指定IPC_CREAT<br />
<br />
 为了访问一个现存队列， 决不能指定IPC_PRIVATE作为键。因为这是一个特殊的键值，它总是用于创建一个新队列。为了访问一个用IPC_PRIVATE键创建的现存队列，一定要知道与该队列相结合的标识符，然后在其他IPC调用中使用该标识符。<br />
<br />
 如果希望创建一个新的IPC结构， 而且要确保不是引用具有同一标识符的一个现行IPC结构，那么必须在flag中同时制定IPC_CREAT和IPC_EXCL位。这样做了以后 如果IPC结构已存在就会造成出错， 返回EEXIST（这与制定O_CREAT和O_EXCL标志的open相类似） </td></tr>
<tr>
<td rowspan="3">02</td><td rowspan="3">优点和缺点</td><td>IPC结构是在系统范围内起作用的，没有访问计数</td><td>如果进程创建了一个消息队列， 在该队列中放入了几则消息， 然后终止， 但是该消息队列及其内容并不会被删除。它们余留哎系统中直至出现下述情况：<br />
1. 由某个进程调用msgrcv或msgctl读消息或删除消息队列；<br />
 2. 或某个进程执行ipcrm命令删除消息队列；<br />
 3. 或由正在再启动的系统删除消息队列。<br />
<br />
与管道相比， 当最后一个访问管道的进程终止时， 管道就被完全删除了。与FIFO相比， 虽然当最后一个引用FIFO的继承终止时其名字仍保留在系统中， 直至显式地删除它， 但是留在FIFO中的数据却在此时全部被删除， 于是也就徒有其名了。 </td></tr>
<tr>
<td>IPC结构在文件系统中没有名字</td><td>我们不能像操作其他文件一样操作它们。 为了支持它们不得不增加十几条全新的系统调用；我们不能用ls命令查看IPC对象， 不能用rm命令删除它们， 也不能用chmod命令更改它们的访问权限。 于是， 就不得不增加新的命令ipcs和ipcrm。 </td></tr>
<tr>
<td>IPC不使用文件描述符， 所以不能对它们使用多路转接I/O函数：select和poll</td><td>这就使得难于一次使用多个IPOC结构， 以及在文件或设备I/O中使用IPC结构。 </td></tr>
</table>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>成功 </td></tr>
    <tr><td class="paramname">!0</td><td>失败 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="c15__process__ipc_8cc_source.html">c15_process_ipc.cc</a> 第 <a class="el" href="c15__process__ipc_8cc_source.html#l00520">520</a> 行定义.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
